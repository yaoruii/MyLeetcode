# 644. Maximum Average Subarray II

**那个人说这道题也可以用719，但它不属于：在各种乱七八糟情景下寻找第K小的某个数的情形，所以并没有思路，看了答案**

* 构建候选的solution：一个自然数
* 所有solution形成的搜索空间：长度为x的子数组的平均数，平均数比最小的数大，比最大的数小，所以，无论x和k是多少，solutions在数组的最大数和最小数之间。
* 验证某个solution：之前的几题是寻找第k小的元素，所以是计算小于等于当前solution的元素个数，并记录具体的最大的存在于具体数据结构的元素的值，一旦count==K,返回记录的具体的元素即可。  
所以这一题的特殊之处就是这里：怎么搞呢？
* solution本质上就是子数组的平均数，所以去**看子数组中是否存在子数组长度至少为K同时平均数能否拿到solution**：能达到，solution继续增大，不能达到，solution减少。
* 定义一个check()函数：在这里面用了一些小技巧，比如：1，将求平均再比较转换为求和，2，因为子数组的长度 >= k，所以记录当前索引为(right-k)的前缀和，并追踪最小的前缀和，让当前加上nums[right]后的元素
* traversal search space：从上边也可以看出，可以用binsry search探索搜索空间[min, max]。
