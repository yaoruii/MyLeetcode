# 286. Walls and Gates

```
INF  -1  0  INF
INF INF INF  -1
INF  -1 INF  -1
  0  -1 INF INF
  
After running your function, the 2D grid should be:
3  -1   0   1
2   2   1  -1
1  -1   2  -1
0  -1   3   4
```
大概的思路如下：
* 首先，可以看出是：2d grid的bfs，找到一个源，确定targer，确定什么算“可到达的相邻的邻居”：
* 最开始能想到的是：INF是源，0是目标，-1是不可到达的邻居，剩下的上下左右的邻居都可达到。对每一个INF进行bfs，返回距离或者不存在路径，返回INF，将该源在数组中的值赋值为返回的值。
* 这就是答案中的**“暴力解法”**，稍微一想，就发现可以优化，于是有了：
* 在寻找某一个INF的到最近的0路径中，遇到的INF，后者的最短路径在求前者INF的最短路径的时候就确定了，比如上例，求（0，0）的过程中，我们遇到了（1,0),(2,0),如果（3，0）是（0，0）的最近的0，那么它也是（1，0）最近的0
* 因为，（1，0）到任何可到达的0的路径比（0，0）小1（注意：（0，0）必定经过（1，0）），所以如果存在一个0使得到（1，0）的距离更短，那么加1后，即到（0，0）的距离也是最短的。
* 这样的话，**求得（0，0）的最短路径后，这条路径中的其他的INF的最短路径也确定了，终点和（0，0）的目标0是同一个**
* **但是这样需要追踪具体的路径，目前还不知道如何实现**
* 然后，突然想到可以从0出发，target为INF，遇到INF就令其值为此次bfs遍历中对应的level，也就是离源0的距离。
* 同时，注意：即使一个INF和某个0相连，但是这个0不一定是最短的目标0，所以，迭代到下一个0的时候，**如果碰到了上一个0已经赋值过的INF，也要当成可到达的邻居，对其再次赋值时，调用Math,min()函数，看两个0下的level谁大谁小，取娇小的那个作为最短路径**
* 但是超时了。。。我觉得是因为，每一个INF都可能被遍历很多遍，取觉域其与多少个0在同一个set中。
* 所以，目前
